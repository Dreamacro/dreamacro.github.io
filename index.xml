<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Dreamacro</title><link>http://dreamacro.github.io/</link><description>Recent content on Dreamacro</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><lastBuildDate>Wed, 24 May 2017 16:46:10 +0800</lastBuildDate><atom:link href="http://dreamacro.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>RCTF Commonjs Write Up</title><link>http://dreamacro.github.io/posts/rctf-commonjs-writeup/</link><pubDate>Wed, 24 May 2017 16:46:10 +0800</pubDate><guid>http://dreamacro.github.io/posts/rctf-commonjs-writeup/</guid><description>Commonjs ( 2 solved ) 题目的环境是 Vue + SSR ( Server Side Render ) , 详细信息可以参照官方的示例 Hacknews
辨别的方法也很简单，服务端渲染返回的 HTML 里会带有预填充信息，这里 Vue 的预填充标志是 window.__INITIAL_STATE__
触发漏洞的点
将自己的 commonjs 代码保存，点击 Save 会跳转到 URL /codes/:id 开启一个新的页面，利用模块导入和 const m = require('id') 将模块引入，再次保存 利用服务端渲染得到结果，可以发现依赖的模块进行了一次包装 在客户端中，可以找到对代码进行包装的代码
1 2 3 4 5 6 7 8 9 10 11 function warp (code) { try { const ret = eval(`(function (module, exports, require) { ${code}})`) if (typeof ret !</description></item></channel></rss>